WebAPI - Application Programming Interface - Нещо което ние викаме програмно и то ни връща резултат.
Викаме някакво пърче готов код, подаваме му параметри, то върши някаква работа и връща резултат. Може да се преизползва.
Самият компонент който викаме той има някаква сървърна логика, но няма визуализация, той ни връща само данни.

DbContext - го използваме, за да имаме достъп до базата.
Repository - Целта на едно репозитори е да енкапсулира през някакъв интерфейс(IRepository) достъпа до някакви данни.

REST е една имплементация на SOA която ползва прости HTTP заявки.Единият вида Http Get дава url, другият му връща JSON и го рисува по екрана.
REST е един от стандартите за Web Service. 
В REST всичко е ресурси и операции върху тях. Всики данни в една web услуга могат да се представят като ресурси и да се извършват 
операции върху тях. Entities и нещата от базата са ресурс. Login е ресурс. Един клас един метод, всяко едно такова нещо е ресурс.
Всеки ресурс има URI (адрес).
REST + HTTP + JSON = RESTful Service

Controllers - Те са входната точка на нашият Web API. Всяко едно извикване по http пристига в контролера и ние от там
започваме да работим с data модела и да достъпваме базата и да върнем резултат.

http://localhost:61346/api/student - контролера се казва StudentController

В папката App_Start са всичките инициализиращи файлове.

Как се вдига локален сървър мога да науча ако следвам стъпките в туториала на сайта на asp.net/web-api в 
раздела Deployment and Hosting (Use OWIN to Self-Host Web API 2)

За ауторизация и автентикация мога да видя примерите на сайта в раздел Security, Authentication and Authorization!!!

Използвайки Repository - това е един начин по който всички заявки които имаме си ги рапваме в репозиторита и не си замърсяваме
контролерите, понеже в контролерите могат да станат големи заявки от Select, Where и т.н. Всичко е в конкретни репозиторита.

[AllowAnonymous] - Този атрибут го използваме когато искаме съответният метод да не се Authorize-ва.

...................................................................................................................
В Binding модела слагаме данните които получаваме от User-a. (input модел)
В View Model слагаме данните които показваме на User-a. (output модел) 
...................................................................................................................

Unit tests and Mocking

1. Създавам си нов проект Unit Test Project.
2. Реферирам текущият проект към Конзолното приложение което ще тествам

Пример за създаване на база:

[AssemblyInitialize]
public static void AssemblyInit(TestContext context)
{
	var dbContext = new BugTrackerDbContext();
	dbContext.Database.CreateIfNotExists();
}

Пример за Mock:

var repoMock = new Mock<IRepository<Bug>>();
var bug = new List<Bug>(){new Bug(){}}

repoMock.Setup(repo => repo.Find(It.IsAny<int>())).Return((int id) => bugs.FirstOrDefault(b => b.Id == id));
или
repoMock.Setup(repo => repo.All()).Return(bugs.AsQueryable());
или
repoMock.Setup(repo => repo.Add(It.IsAny<Bug>())).Callback((Bug b) => bugs.Add(b));

var controller = new BugsController(repoMock.Object);
this.SetupController(controller, "bugs");

var result = controller.Get(17).ExecuteAsync(new CancellationToken()).Result;

Assert.AreEqual(HttpStatusCode.OK, result.StatusCode);
// CollectionAssert.AreEquivalent(bugs, result.ToList<Bug>());
var bugFromService = result.Content.ReadAsAsync<Bug>().Result;

Целта на Mocking е да нямам директна връзка към базата, а да ползваме interface през който минаваме и 
през контролера да се подпъхва (injection) обекта през който работиме. Целта е да се прави Unit test, да се тества 
само контролера без да се ползва реалната база с помощта на Mock-ната база.

UnitOfWork е един interface който обединява всички наши repository-та плюс SaveChanges. Неговата идея е да даде възможност
да правиш серия от промени и всички тях да ги Commit-неш заедно като една транзакция или да ги откажеш заедно като 
не ги Commit-неш.

При integration test имаш достъп до базата и до сървиса който тестваш. Пускаш заявки на service подпъхваш му данни в базата
и гледаш дали в базата е ок всичко и дали ти отговаря с правилните неща които трябва да ти върне.
Integration тестовете тестват от UI до Базата данни.

...................................................................................................................
Асинхронни Web Services

Когато една заявка пристигне от AS сървър тя се препраща към ASP.NET съответно ако рънваме през Web Api се
праща на Web Api. Тази заявка се обработва като според Route-а който тя пази в себе си се избира най-подходящият контролер
От този контролер се прави нова инстанция и се извиква съответният action да обработи заявката.

Thread e единица която изпълнява код. Обект на много ниско ниво на който му се казва изпълнявай този код и той хваща и 
почва да го изпълнява. Изпълнявайки го този код се превежда до инструкции към процесора. Процесора взима тези инструкции
и ги обработва.

...................................................................................................................
bug.Status = (BugStatus) Enum.Parse(typeof(BugStatus), model.Status);
...................................................................................................................
config.Formatters.JsonFormatter.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver();
Този ред го вкарвам в Web.Api.Config файла, за да сериализирам изходящият json да е CamelCase!!!
...................................................................................................................
public static Expression<Func<Bug, BugViewModel>> Create()
        {
            return b => new BugViewModel()
            {
                Id = b.Id,
                Title = b.Title,
                Status = b.Status.ToString(),
                Author = b.Author == null ? null : b.Author.UserName,
                DateCreated = b.DateCreated
            };
        } 
Func е метод който приема Bug и връща BugViewModel.
Експрешъните са методи които пазят логиката за проектиране на данни.
Expression превежда проекцията до SQL заявка без да я материализира!!!
...................................................................................................................
Как да си вдигна тестов сървър погледни последната подготовка за изпита 2:20:00 !!!
...................................................................................................................

 



 

